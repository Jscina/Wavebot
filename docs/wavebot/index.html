<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>wavebot API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>wavebot</code></h1>
</header>
<section id="section-intro">
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="wavebot.camera" href="camera.html">wavebot.camera</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="wavebot.config" href="config.html">wavebot.config</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="wavebot.servos" href="servos.html">wavebot.servos</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="wavebot.vision" href="vision.html">wavebot.vision</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="wavebot.camera_stream"><code class="name flex">
<span>def <span class="ident">camera_stream</span></span>(<span>) ‑> Generator[numpy.ndarray, None, None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def camera_stream() -&gt; Generator[np.ndarray, None, None]:
    &#34;&#34;&#34;
    Yields frames (as np.ndarray) from either PiCamera (if USE_USB_CAMERA=False)
    or from USB camera via OpenCV VideoCapture (if USE_USB_CAMERA=True).
    &#34;&#34;&#34;
    if USE_USB_CAMERA or PiCamera is None:
        logger.info(&#34;Using USB camera&#34;)
        cap = cv2.VideoCapture(0, cv2.CAP_V4L2)
        cap.set(cv2.CAP_PROP_FRAME_WIDTH, FRAME_WIDTH)
        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FRAME_HEIGHT)
        cap.set(cv2.CAP_PROP_FPS, 30)

        if not cap.isOpened():
            print(&#34;Could not open USB camera.&#34;, file=sys.stderr)
            return

        try:
            while True:
                ret, frame = cap.read()
                if not ret:
                    break
                yield frame
        finally:
            cap.release()

    else:
        logger.info(&#34;Using PiCamera&#34;)
        camera = PiCamera()
        try:
            camera.resolution = (FRAME_WIDTH, FRAME_HEIGHT)
            camera.framerate = 30
            stream = PiRGBArray(camera, size=(FRAME_WIDTH, FRAME_HEIGHT))  # type: ignore
            try:
                for frame_data in camera.capture_continuous(
                    stream, format=&#34;bgr&#34;, use_video_port=True
                ):
                    frame = frame_data.array
                    yield frame
                    # Clear the PiRGBArray to prepare for next frame
                    stream.truncate(0)
                    stream.seek(0)
            finally:
                stream.close()
        finally:
            camera.close()</code></pre>
</details>
<div class="desc"><p>Yields frames (as np.ndarray) from either PiCamera (if USE_USB_CAMERA=False)
or from USB camera via OpenCV VideoCapture (if USE_USB_CAMERA=True).</p></div>
</dd>
<dt id="wavebot.detect_faces"><code class="name flex">
<span>def <span class="ident">detect_faces</span></span>(<span>frame: numpy.ndarray) ‑> list[tuple[int, int, int, int]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect_faces(frame: np.ndarray) -&gt; FaceBoxList:
    &#34;&#34;&#34;
    Detects faces in a frame using OpenCV&#39;s DNN model.
    :param frame: Input image frame.
    :return: List of bounding boxes (x, y, w, h).
    &#34;&#34;&#34;
    height, width = frame.shape[:2]
    blob = cv2.dnn.blobFromImage(frame, 1.0, (300, 300), (104, 177, 123), swapRB=True)
    model.setInput(blob)
    detections = model.forward()

    faces: FaceBoxList = []
    for i in range(detections.shape[2]):
        confidence: float = detections[0, 0, i, 2]
        if confidence &gt; 0.5:
            x1, y1, x2, y2 = detections[0, 0, i, 3:7] * np.array(
                [width, height, width, height]
            )
            faces.append((int(x1), int(y1), int(x2 - x1), int(y2 - y1)))
    return faces</code></pre>
</details>
<div class="desc"><p>Detects faces in a frame using OpenCV's DNN model.
:param frame: Input image frame.
:return: List of bounding boxes (x, y, w, h).</p></div>
</dd>
<dt id="wavebot.draw_faces"><code class="name flex">
<span>def <span class="ident">draw_faces</span></span>(<span>controller: <a title="wavebot.servos.ServoController" href="servos.html#wavebot.servos.ServoController">ServoController</a>,<br>frame: numpy.ndarray,<br>faces: list[tuple[int, int, int, int]],<br>on_face_detected: Callable[[], None]) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_faces(
    controller: ServoController,
    frame: np.ndarray,
    faces: FaceBoxList,
    on_face_detected: Callable[[], None],
) -&gt; bool:
    &#34;&#34;&#34;
    Draws bounding boxes and centers the eyes on detected faces.
    :param frame: Image to draw on.
    :param faces: List of face bounding boxes.
    :param on_face_detected: Callback when a face is found.
    :return: True if face detected, False otherwise.
    &#34;&#34;&#34;
    if not faces:
        return False

    origin_x = FRAME_WIDTH // 2
    origin_y = FRAME_HEIGHT // 2

    for x, y, w, h in faces:
        center_x = x + w // 2
        center_y = y + h // 2
        relative_x = center_x - origin_x
        relative_y = origin_y - center_y
        reversed_x = origin_x - (center_x - origin_x)

        cv2.rectangle(frame, (x, y), (x + w, y + h), (255, 0, 0), 2)
        cv2.circle(frame, (center_x, center_y), 2, (0, 0, 255), -1)
        cv2.putText(
            frame,
            f&#34;({relative_x}, {relative_y})&#34;,
            (center_x + 5, center_y - 5),
            cv2.FONT_HERSHEY_SIMPLEX,
            0.4,
            (0, 0, 0),
            1,
        )

        controller.queue_update_servos(
            reversed_x, relative_y, FRAME_WIDTH, FRAME_HEIGHT
        )
        on_face_detected()

    return True</code></pre>
</details>
<div class="desc"><p>Draws bounding boxes and centers the eyes on detected faces.
:param frame: Image to draw on.
:param faces: List of face bounding boxes.
:param on_face_detected: Callback when a face is found.
:return: True if face detected, False otherwise.</p></div>
</dd>
<dt id="wavebot.draw_quadrants"><code class="name flex">
<span>def <span class="ident">draw_quadrants</span></span>(<span>frame: numpy.ndarray) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_quadrants(frame: np.ndarray) -&gt; None:
    &#34;&#34;&#34;
    Draws vertical and horizontal center lines.
    &#34;&#34;&#34;
    rows, cols = frame.shape[:2]
    cv2.line(frame, (0, rows // 2), (cols, rows // 2), (0, 255, 0), 1)
    cv2.line(frame, (cols // 2, 0), (cols // 2, rows), (0, 255, 0), 1)</code></pre>
</details>
<div class="desc"><p>Draws vertical and horizontal center lines.</p></div>
</dd>
<dt id="wavebot.set_servo_angle"><code class="name flex">
<span>def <span class="ident">set_servo_angle</span></span>(<span>channel: <a title="wavebot.config.Channel" href="config.html#wavebot.config.Channel">Channel</a>,<br>angle: float) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_servo_angle(channel: Channel, angle: float) -&gt; None:
    &#34;&#34;&#34;
    Immediately sets the servo at &#39;channel&#39; to &#39;angle&#39; degrees on this thread,
    clamped to a safe range. Updates SERVO_POSITIONS.
    This is called inside the worker thread (or if hardware is not available).
    &#34;&#34;&#34;
    old_angle = SERVO_POSITIONS.get(channel.value, 0.0)
    servo_min, servo_max = SERVO_LIMITS.get(channel.value, (0.0, 180.0))
    clamped_angle = max(servo_min, min(angle, servo_max))
    servo_type = channel.__class__.__name__

    logger.info(
        f&#34;set_servo_angle({servo_type}.{channel.name}): &#34;
        f&#34;old={old_angle:.2f} → requested={angle:.2f} → clamped={clamped_angle:.2f} &#34;
        f&#34;(HW={HARDWARE_AVAILABLE})&#34;
    )

    SERVO_POSITIONS[channel.value] = clamped_angle

    if not HARDWARE_AVAILABLE:
        return

    pulse_length: float = (clamped_angle * 1000 // 180) + 1000
    duty_cycle: int = int(pulse_length * 65535 / (1 / pwm.frequency) / 1_000_000)
    pwm.channels[channel.value].duty_cycle = duty_cycle</code></pre>
</details>
<div class="desc"><p>Immediately sets the servo at 'channel' to 'angle' degrees on this thread,
clamped to a safe range. Updates SERVO_POSITIONS.
This is called inside the worker thread (or if hardware is not available).</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="wavebot.Channel"><code class="flex name class">
<span>class <span class="ident">Channel</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Channel(Enum):
    &#34;&#34;&#34;Mapping of servo motor channels to their corresponding GPIO pins&#34;&#34;&#34;

    EYE_LEFT_X = 0
    EYE_LEFT_Y = 1
    EYE_RIGHT_X = 2
    EYE_RIGHT_Y = 3
    NECK_X = 8
    NECK_Y = 9</code></pre>
</details>
<div class="desc"><p>Mapping of servo motor channels to their corresponding GPIO pins</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="wavebot.Channel.EYE_LEFT_X"><code class="name">var <span class="ident">EYE_LEFT_X</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wavebot.Channel.EYE_LEFT_Y"><code class="name">var <span class="ident">EYE_LEFT_Y</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wavebot.Channel.EYE_RIGHT_X"><code class="name">var <span class="ident">EYE_RIGHT_X</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wavebot.Channel.EYE_RIGHT_Y"><code class="name">var <span class="ident">EYE_RIGHT_Y</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wavebot.Channel.NECK_X"><code class="name">var <span class="ident">NECK_X</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wavebot.Channel.NECK_Y"><code class="name">var <span class="ident">NECK_Y</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="wavebot.ServoController"><code class="flex name class">
<span>class <span class="ident">ServoController</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServoController:
    &#34;&#34;&#34;
    Manages all servo commands via a background worker thread.
    Commands are queued; the worker processes them sequentially.
    Supports:
      - Gradual movement
      - Re-centering
      - Face-tracking updates
    &#34;&#34;&#34;

    def __init__(self):
        self._command_queue = Queue()
        self._thread = Thread(target=self._worker, daemon=True)
        self._running = False

    def start(self):
        &#34;&#34;&#34;Starts the worker thread if it&#39;s not already running.&#34;&#34;&#34;
        if not self._running:
            self._running = True
            self._thread.start()
            logger.info(&#34;Servo worker thread started.&#34;)

    def stop(self):
        &#34;&#34;&#34;Stops the worker thread gracefully.&#34;&#34;&#34;
        self._command_queue.put(None)
        self._thread.join()
        logger.info(&#34;Servo worker thread stopped.&#34;)

    def queue_servo_angle(self, channel: Channel, angle: float):
        &#34;&#34;&#34;
        Immediately queue a single servo angle command.
        The worker will call &#39;set_servo_angle&#39; internally.
        &#34;&#34;&#34;
        self._command_queue.put((&#34;MOVE&#34;, channel, angle))

    def queue_move_servo_gradually(
        self,
        channel: Channel,
        target_angle: float,
        step: float = 1.0,
        delay: float = 0.1,
    ):
        &#34;&#34;&#34;
        Moves the given servo channel from its current angle to &#39;target_angle&#39;,
        step-by-step, inserting a small delay between each sub-step.
        This entire motion is queued and processed asynchronously.
        &#34;&#34;&#34;
        current_angle = SERVO_POSITIONS.get(channel.value, 90.0)
        servo_min, servo_max = SERVO_LIMITS.get(channel.value, (0.0, 180.0))
        target_clamped = max(servo_min, min(target_angle, servo_max))

        if current_angle &lt; target_clamped:
            angle_range = range(int(current_angle), int(target_clamped) + 1, int(step))
        else:
            angle_range = range(int(current_angle), int(target_clamped) - 1, -int(step))

        for ang in angle_range:
            clamped_ang = max(servo_min, min(float(ang), servo_max))
            self._command_queue.put((&#34;MOVE&#34;, channel, clamped_ang))
            if delay &gt; 0:
                self._command_queue.put((&#34;SLEEP&#34;, delay))

        self._command_queue.put((&#34;MOVE&#34;, channel, target_clamped))

    def queue_center_servos(self):
        &#34;&#34;&#34;
        Resets all servo motors to their original (default) positions
        as stored in DEFAULT_SERVO_POSITIONS.
        Each command is queued so they move in sequence, but not gradually.
        &#34;&#34;&#34;
        logger.info(f&#34;queue_center_servos() called (HW={HARDWARE_AVAILABLE})&#34;)
        for channel_val, default_angle in DEFAULT_SERVO_POSITIONS.items():
            channel = Channel(channel_val)
            self._command_queue.put((&#34;MOVE&#34;, channel, default_angle))

    def queue_update_servos(self, x_val: int, y_val: int, width: int, height: int):
        &#34;&#34;&#34;
        Moves the eye and neck servos based on face coordinates (async).
        &#34;&#34;&#34;
        logger.info(
            f&#34;update_servos(x_val={x_val}, y_val={y_val}, width={width}, height={height})&#34;
        )

        eye_x_angle_diff: float = x_val * 50.0 / width
        neck_x_angle_diff: float = x_val * 25.0 / width

        if x_val &lt; 0:
            self.queue_servo_angle(Channel.EYE_LEFT_X, 125.0 - eye_x_angle_diff)
            self.queue_servo_angle(Channel.EYE_RIGHT_X, 130.0 - eye_x_angle_diff)
        elif x_val &gt; 0:
            self.queue_servo_angle(Channel.EYE_LEFT_X, 125.0 + eye_x_angle_diff)
            self.queue_servo_angle(Channel.EYE_RIGHT_X, 130.0 + eye_x_angle_diff)

        ley_angle: float = 110.0 - (y_val * (120.0 - 300.0) / height)
        rey_angle: float = 110.0 + (y_val * (110.0 - 300.0) / height)
        self.queue_servo_angle(Channel.EYE_LEFT_Y, ley_angle)
        self.queue_servo_angle(Channel.EYE_RIGHT_Y, rey_angle)

        current_neck_x = SERVO_POSITIONS[Channel.NECK_X.value]
        new_neck_x = current_neck_x
        if abs(x_val) &gt; width // 6:
            if x_val &lt; 0:
                new_neck_x = 74.0 - neck_x_angle_diff
            else:
                new_neck_x = 74.0 + neck_x_angle_diff
        if new_neck_x != current_neck_x:
            self.queue_move_servo_gradually(Channel.NECK_X, new_neck_x)

        neck_y_angle_diff: float = y_val * 20.0 / height
        current_neck_y = SERVO_POSITIONS[Channel.NECK_Y.value]
        new_neck_y = current_neck_y
        if abs(y_val) &gt; height // 6:
            if y_val &gt; 0:
                new_neck_y = 20.0 - neck_y_angle_diff
            else:
                new_neck_y = 20.0 + neck_y_angle_diff
        if new_neck_y != current_neck_y:
            self.queue_move_servo_gradually(Channel.NECK_Y, new_neck_y)

    def _worker(self):
        &#34;&#34;&#34;
        Worker thread loop:
          - Fetch commands from the queue
          - &#39;MOVE&#39; =&gt; call set_servo_angle
          - &#39;SLEEP&#39; =&gt; time.sleep
          - None =&gt; exit
        &#34;&#34;&#34;
        while True:
            command = self._command_queue.get()
            if command is None:
                break

            cmd_type = command[0]
            if cmd_type == &#34;MOVE&#34;:
                _, channel, angle = command
                set_servo_angle(channel, angle)

            elif cmd_type == &#34;SLEEP&#34;:
                _, duration = command
                time.sleep(duration)

            self._command_queue.task_done()</code></pre>
</details>
<div class="desc"><p>Manages all servo commands via a background worker thread.
Commands are queued; the worker processes them sequentially.</p>
<h2 id="supports">Supports</h2>
<ul>
<li>Gradual movement</li>
<li>Re-centering</li>
<li>Face-tracking updates</li>
</ul></div>
<h3>Methods</h3>
<dl>
<dt id="wavebot.ServoController.queue_center_servos"><code class="name flex">
<span>def <span class="ident">queue_center_servos</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queue_center_servos(self):
    &#34;&#34;&#34;
    Resets all servo motors to their original (default) positions
    as stored in DEFAULT_SERVO_POSITIONS.
    Each command is queued so they move in sequence, but not gradually.
    &#34;&#34;&#34;
    logger.info(f&#34;queue_center_servos() called (HW={HARDWARE_AVAILABLE})&#34;)
    for channel_val, default_angle in DEFAULT_SERVO_POSITIONS.items():
        channel = Channel(channel_val)
        self._command_queue.put((&#34;MOVE&#34;, channel, default_angle))</code></pre>
</details>
<div class="desc"><p>Resets all servo motors to their original (default) positions
as stored in DEFAULT_SERVO_POSITIONS.
Each command is queued so they move in sequence, but not gradually.</p></div>
</dd>
<dt id="wavebot.ServoController.queue_move_servo_gradually"><code class="name flex">
<span>def <span class="ident">queue_move_servo_gradually</span></span>(<span>self,<br>channel: <a title="wavebot.config.Channel" href="config.html#wavebot.config.Channel">Channel</a>,<br>target_angle: float,<br>step: float = 1.0,<br>delay: float = 0.1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queue_move_servo_gradually(
    self,
    channel: Channel,
    target_angle: float,
    step: float = 1.0,
    delay: float = 0.1,
):
    &#34;&#34;&#34;
    Moves the given servo channel from its current angle to &#39;target_angle&#39;,
    step-by-step, inserting a small delay between each sub-step.
    This entire motion is queued and processed asynchronously.
    &#34;&#34;&#34;
    current_angle = SERVO_POSITIONS.get(channel.value, 90.0)
    servo_min, servo_max = SERVO_LIMITS.get(channel.value, (0.0, 180.0))
    target_clamped = max(servo_min, min(target_angle, servo_max))

    if current_angle &lt; target_clamped:
        angle_range = range(int(current_angle), int(target_clamped) + 1, int(step))
    else:
        angle_range = range(int(current_angle), int(target_clamped) - 1, -int(step))

    for ang in angle_range:
        clamped_ang = max(servo_min, min(float(ang), servo_max))
        self._command_queue.put((&#34;MOVE&#34;, channel, clamped_ang))
        if delay &gt; 0:
            self._command_queue.put((&#34;SLEEP&#34;, delay))

    self._command_queue.put((&#34;MOVE&#34;, channel, target_clamped))</code></pre>
</details>
<div class="desc"><p>Moves the given servo channel from its current angle to 'target_angle',
step-by-step, inserting a small delay between each sub-step.
This entire motion is queued and processed asynchronously.</p></div>
</dd>
<dt id="wavebot.ServoController.queue_servo_angle"><code class="name flex">
<span>def <span class="ident">queue_servo_angle</span></span>(<span>self,<br>channel: <a title="wavebot.config.Channel" href="config.html#wavebot.config.Channel">Channel</a>,<br>angle: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queue_servo_angle(self, channel: Channel, angle: float):
    &#34;&#34;&#34;
    Immediately queue a single servo angle command.
    The worker will call &#39;set_servo_angle&#39; internally.
    &#34;&#34;&#34;
    self._command_queue.put((&#34;MOVE&#34;, channel, angle))</code></pre>
</details>
<div class="desc"><p>Immediately queue a single servo angle command.
The worker will call 'set_servo_angle' internally.</p></div>
</dd>
<dt id="wavebot.ServoController.queue_update_servos"><code class="name flex">
<span>def <span class="ident">queue_update_servos</span></span>(<span>self, x_val: int, y_val: int, width: int, height: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queue_update_servos(self, x_val: int, y_val: int, width: int, height: int):
    &#34;&#34;&#34;
    Moves the eye and neck servos based on face coordinates (async).
    &#34;&#34;&#34;
    logger.info(
        f&#34;update_servos(x_val={x_val}, y_val={y_val}, width={width}, height={height})&#34;
    )

    eye_x_angle_diff: float = x_val * 50.0 / width
    neck_x_angle_diff: float = x_val * 25.0 / width

    if x_val &lt; 0:
        self.queue_servo_angle(Channel.EYE_LEFT_X, 125.0 - eye_x_angle_diff)
        self.queue_servo_angle(Channel.EYE_RIGHT_X, 130.0 - eye_x_angle_diff)
    elif x_val &gt; 0:
        self.queue_servo_angle(Channel.EYE_LEFT_X, 125.0 + eye_x_angle_diff)
        self.queue_servo_angle(Channel.EYE_RIGHT_X, 130.0 + eye_x_angle_diff)

    ley_angle: float = 110.0 - (y_val * (120.0 - 300.0) / height)
    rey_angle: float = 110.0 + (y_val * (110.0 - 300.0) / height)
    self.queue_servo_angle(Channel.EYE_LEFT_Y, ley_angle)
    self.queue_servo_angle(Channel.EYE_RIGHT_Y, rey_angle)

    current_neck_x = SERVO_POSITIONS[Channel.NECK_X.value]
    new_neck_x = current_neck_x
    if abs(x_val) &gt; width // 6:
        if x_val &lt; 0:
            new_neck_x = 74.0 - neck_x_angle_diff
        else:
            new_neck_x = 74.0 + neck_x_angle_diff
    if new_neck_x != current_neck_x:
        self.queue_move_servo_gradually(Channel.NECK_X, new_neck_x)

    neck_y_angle_diff: float = y_val * 20.0 / height
    current_neck_y = SERVO_POSITIONS[Channel.NECK_Y.value]
    new_neck_y = current_neck_y
    if abs(y_val) &gt; height // 6:
        if y_val &gt; 0:
            new_neck_y = 20.0 - neck_y_angle_diff
        else:
            new_neck_y = 20.0 + neck_y_angle_diff
    if new_neck_y != current_neck_y:
        self.queue_move_servo_gradually(Channel.NECK_Y, new_neck_y)</code></pre>
</details>
<div class="desc"><p>Moves the eye and neck servos based on face coordinates (async).</p></div>
</dd>
<dt id="wavebot.ServoController.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;Starts the worker thread if it&#39;s not already running.&#34;&#34;&#34;
    if not self._running:
        self._running = True
        self._thread.start()
        logger.info(&#34;Servo worker thread started.&#34;)</code></pre>
</details>
<div class="desc"><p>Starts the worker thread if it's not already running.</p></div>
</dd>
<dt id="wavebot.ServoController.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    &#34;&#34;&#34;Stops the worker thread gracefully.&#34;&#34;&#34;
    self._command_queue.put(None)
    self._thread.join()
    logger.info(&#34;Servo worker thread stopped.&#34;)</code></pre>
</details>
<div class="desc"><p>Stops the worker thread gracefully.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="wavebot.camera" href="camera.html">wavebot.camera</a></code></li>
<li><code><a title="wavebot.config" href="config.html">wavebot.config</a></code></li>
<li><code><a title="wavebot.servos" href="servos.html">wavebot.servos</a></code></li>
<li><code><a title="wavebot.vision" href="vision.html">wavebot.vision</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="wavebot.camera_stream" href="#wavebot.camera_stream">camera_stream</a></code></li>
<li><code><a title="wavebot.detect_faces" href="#wavebot.detect_faces">detect_faces</a></code></li>
<li><code><a title="wavebot.draw_faces" href="#wavebot.draw_faces">draw_faces</a></code></li>
<li><code><a title="wavebot.draw_quadrants" href="#wavebot.draw_quadrants">draw_quadrants</a></code></li>
<li><code><a title="wavebot.set_servo_angle" href="#wavebot.set_servo_angle">set_servo_angle</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="wavebot.Channel" href="#wavebot.Channel">Channel</a></code></h4>
<ul class="two-column">
<li><code><a title="wavebot.Channel.EYE_LEFT_X" href="#wavebot.Channel.EYE_LEFT_X">EYE_LEFT_X</a></code></li>
<li><code><a title="wavebot.Channel.EYE_LEFT_Y" href="#wavebot.Channel.EYE_LEFT_Y">EYE_LEFT_Y</a></code></li>
<li><code><a title="wavebot.Channel.EYE_RIGHT_X" href="#wavebot.Channel.EYE_RIGHT_X">EYE_RIGHT_X</a></code></li>
<li><code><a title="wavebot.Channel.EYE_RIGHT_Y" href="#wavebot.Channel.EYE_RIGHT_Y">EYE_RIGHT_Y</a></code></li>
<li><code><a title="wavebot.Channel.NECK_X" href="#wavebot.Channel.NECK_X">NECK_X</a></code></li>
<li><code><a title="wavebot.Channel.NECK_Y" href="#wavebot.Channel.NECK_Y">NECK_Y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wavebot.ServoController" href="#wavebot.ServoController">ServoController</a></code></h4>
<ul class="">
<li><code><a title="wavebot.ServoController.queue_center_servos" href="#wavebot.ServoController.queue_center_servos">queue_center_servos</a></code></li>
<li><code><a title="wavebot.ServoController.queue_move_servo_gradually" href="#wavebot.ServoController.queue_move_servo_gradually">queue_move_servo_gradually</a></code></li>
<li><code><a title="wavebot.ServoController.queue_servo_angle" href="#wavebot.ServoController.queue_servo_angle">queue_servo_angle</a></code></li>
<li><code><a title="wavebot.ServoController.queue_update_servos" href="#wavebot.ServoController.queue_update_servos">queue_update_servos</a></code></li>
<li><code><a title="wavebot.ServoController.start" href="#wavebot.ServoController.start">start</a></code></li>
<li><code><a title="wavebot.ServoController.stop" href="#wavebot.ServoController.stop">stop</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
